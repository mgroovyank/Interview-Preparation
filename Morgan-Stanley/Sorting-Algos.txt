Bubble Sort

4 1 5 2 3
1 4 5 2 3
1 4 5 2 3
1 4 2 5 3
1 4 2 3 5
largest element is in its place - I'm shiting the laregst element to right side
Go till second last element
1 4 2 3 5
1 2 4 3 5
1 2 3 4 5
now second last element is in its place
Time complexity: O(N^2)


for(int i=0;i<n-1;i++){
   bool isSwap = false;
  for(int j=0;j<=n-2-i;j++){
        if(arr[j] > arr[j+1]){
		swap(arr[j], arr[j+1]);
                isSwap = true;
	}
    }
   if(isSwap == false){
        // array already sorted
        break;
    }
}




Selection Sort

4 1 5 2 3
1 4 5 2 3
1 2 5 4 3
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5

for(int i=0;i<n-1;i++){
   int smallestElementIdx = i;
   for(int j=i+1;j<n;j++){
       if(arr[smallestElementIdx] > arr[j]){
             smallestElementIdx = j;
         }
    }
   swap(arr[i], arr[smallestElementIdx]);
}

Time Complexity: O(N^2)

Insertion Sort

4 1 5 2 3
4 _ 5 2 3 -> 1 4 5 2 3 (shifting elements to right)
1 4 _ 2 3 -> 1 4 5 2 3 (shifting elements to right)
1 4 5 _ 3 -> 1 2 4 5 3 (shifting elements to right)
1 2 4 5 _ -> 1 2 3 4 5 (shifting elements to right)

for(int i=1;i<n;i++){
   int temp = arr[i];
   int j = i-1;
   while(j>=0 && arr[j] > temp){
    arr[j+1] = arr[j];
    j--;
   }
   arr[j+1] = temp;
    
}

Time Complexity: O(N^2)


Quick Sort
pivot and partition

5 2 6 4 1 3
5 2 6 4 1 _3_
2 1 3 5 6 4
2 _1_ 3 5 6 _4_
1 2 3 4 5 6
1 2 3 4 5 _6_
1 2 3 4 5 6

int partition(arr, start, end){
   pivot = arr[end];
   lastSmallerElementIdx = start-1;
   for(j=start;j<end;j++){
       if(arr[j] > pivot){
              continue;
        }
       lastSmallerElementIdx++;
       swap(arr[lastSmallerIdx], arr[j]);
   }
   lastSmallerIdx++;
   swap(arr[lastSmallerIdx], arr[pivot]);
   return lastSmallerIdx;
}
quicksort(arr, start, end){
   if(start < end){
       pivot = partition(arr, start, end);
       quicksort(arr, start, pivot-1);
       quicksort(arr, pivot+1, end);
   }

}

Time Complexity: O(NlogN) - avg, worst case - O(N^2)(pivot is always smallest/largest)

Space Complexity: O(1) since we ignore recursion stack memory
better space complexity than merge sort

Merge Sort
divide and conquer

12 31 35 8 32 17
12 31 _35_ 8 32 17
_12_ 31 _35_ 8 32 17
12 31 _35_ 8 _32_ 17
12 31 _35_ _8_ _32_ _17_
12 31 _35_ 8 17 32
merge
8 12 17 31 32 35

void mergesort(arr, start, end){
    if(start < end){
        int mid = start + (end-start)/2;
        mergesort(arr, start, mid);
        mergesort(arr, mid+1, end);
        merge(arr, start, mid, end);
    }
}

merge(arr, start, mid, end){
   int left = start;
   int right = mid+1;
   int[] sorted = []; 
   while(left<=mid && right<=end){
       if(left <= right){
           sorted.insert(left++);
       }else {
           sorted.insert(right++);   
       }
   }
   while(left<=mid){
      sorted.insert(left++);
   }
   while(right<=end){
      sorted.insert(right++);  
   }
   int i = 0;
   for(start; start<=end; start++){
      arr[start] = sorted[i++];
   }

}

Time Complexity: merge=O(N), at logN levels I merge => O(N*logN)
Space Complexity: O(N)




